'use strict';

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = identifierfy;

var _esutils = require('esutils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Follow Babel's implementation:
// <https://github.com/babel/babel/blob/add96d626d98133e26f62ec4c2aeee655bed069a/packages/babel-types/src/validators.js#L153:L164>
function isValidIdentifier(name) {
  return !_esutils.keyword.isReservedWordES6(name, true) && _esutils.keyword.isIdentifierNameES6(name);
}

// Rewrite the name until it forms a valid identifier.
function identifierfy(name) {
  var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var _ref$prefixInvalidIde = _ref.prefixInvalidIdentifiers;
  var prefixInvalidIdentifiers = _ref$prefixInvalidIde === undefined ? true : _ref$prefixInvalidIde;
  var _ref$prefixReservedWo = _ref.prefixReservedWords;
  var prefixReservedWords = _ref$prefixReservedWo === undefined ? true : _ref$prefixReservedWo;

  // Start with a valid character. This way if the first character in the name
  // is not allowed to be used as the first character it can be prefixed with
  // an underscore, without having to be dropped. The same goes for if the name
  // is a reserved word.
  var intermediate = '_';

  // Flag whether the previous character was invalid (and thus dropped).
  var prevWasInvalid = false;

  // Use for/of to iterate over the code points. This way surrogate pairs can
  // be avoided.
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(name), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var char = _step.value;

      // Try to uppercase the immediately following (not all characters have an
      // case equivalent though). Ignore if the dropped character was at the front
      // of the name.
      if (prevWasInvalid && intermediate !== '_') {
        char = char.toUpperCase();
      }

      // Only include characters if the name remains valid.
      if (isValidIdentifier(intermediate + char)) {
        intermediate += char;
        prevWasInvalid = false;
      } else {
        prevWasInvalid = true;
      }
    }

    // Return `null` if no characters from the original name survive the process.
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (intermediate === '_') return null;

  // If the name is valid without the underscore prefix return it as such,
  // otherwise retain it, unless directed otherwise.
  var withoutPrefix = intermediate.slice(1);
  if (isValidIdentifier(withoutPrefix)) {
    return withoutPrefix;
  } else if (prefixInvalidIdentifiers && prefixReservedWords) {
    return intermediate;
  } else {
    var isIdentifierName = _esutils.keyword.isIdentifierNameES6(withoutPrefix);
    var isReservedWord = _esutils.keyword.isReservedWordES6(withoutPrefix, true);
    if (!isIdentifierName && !prefixInvalidIdentifiers || isReservedWord && !prefixReservedWords) {
      return withoutPrefix;
    } else {
      return intermediate;
    }
  }
}
module.exports = exports['default'];
//# sourceMappingURL=index.js.map