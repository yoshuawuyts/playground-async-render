{"version":3,"sources":["src/index.js"],"names":[],"mappings":";;;;;;;;;kBASwB;;;;;;;;AALxB,SAAS,iBAAT,CAA4B,IAA5B,EAAkC;AAChC,SAAO,CAAC,iBAAQ,iBAAR,CAA0B,IAA1B,EAAgC,IAAhC,CAAD,IAA0C,iBAAQ,mBAAR,CAA4B,IAA5B,CAA1C,CADyB;CAAlC;;;AAKe,SAAS,YAAT,CAAuB,IAAvB,EAAmG;mEAAJ,kBAAI;;mCAApE,yBAAoE;MAApE,iEAA2B,6BAAyC;mCAAnC,oBAAmC;MAAnC,4DAAsB,6BAAa;;;;;;AAKhH,MAAI,eAAe,GAAf;;;AAL4G,MAQ5G,iBAAiB,KAAjB;;;;AAR4G;;;;;AAYhH,oDAAiB,YAAjB,oGAAuB;UAAd,mBAAc;;;;;AAIrB,UAAI,kBAAkB,iBAAiB,GAAjB,EAAsB;AAC1C,eAAO,KAAK,WAAL,EAAP,CAD0C;OAA5C;;;AAJqB,UASjB,kBAAkB,eAAe,IAAf,CAAtB,EAA4C;AAC1C,wBAAgB,IAAhB,CAD0C;AAE1C,yBAAiB,KAAjB,CAF0C;OAA5C,MAGO;AACL,yBAAiB,IAAjB,CADK;OAHP;KATF;;;;;;;;;;;;;;;;GAZgH;;AA8BhH,MAAI,iBAAiB,GAAjB,EAAsB,OAAO,IAAP,CAA1B;;;;AA9BgH,MAkC1G,gBAAgB,aAAa,KAAb,CAAmB,CAAnB,CAAhB,CAlC0G;AAmChH,MAAI,kBAAkB,aAAlB,CAAJ,EAAsC;AACpC,WAAO,aAAP,CADoC;GAAtC,MAEO,IAAI,4BAA4B,mBAA5B,EAAiD;AAC1D,WAAO,YAAP,CAD0D;GAArD,MAEA;AACL,QAAM,mBAAmB,iBAAQ,mBAAR,CAA4B,aAA5B,CAAnB,CADD;AAEL,QAAM,iBAAiB,iBAAQ,iBAAR,CAA0B,aAA1B,EAAyC,IAAzC,CAAjB,CAFD;AAGL,QAAI,CAAC,gBAAD,IAAqB,CAAC,wBAAD,IAA6B,kBAAkB,CAAC,mBAAD,EAAsB;AAC5F,aAAO,aAAP,CAD4F;KAA9F,MAEO;AACL,aAAO,YAAP,CADK;KAFP;GALK;CArCM","file":"index.js","sourcesContent":["import { keyword } from 'esutils'\n\n// Follow Babel's implementation:\n// <https://github.com/babel/babel/blob/add96d626d98133e26f62ec4c2aeee655bed069a/packages/babel-types/src/validators.js#L153:L164>\nfunction isValidIdentifier (name) {\n  return !keyword.isReservedWordES6(name, true) && keyword.isIdentifierNameES6(name)\n}\n\n// Rewrite the name until it forms a valid identifier.\nexport default function identifierfy (name, { prefixInvalidIdentifiers = true, prefixReservedWords = true } = {}) {\n  // Start with a valid character. This way if the first character in the name\n  // is not allowed to be used as the first character it can be prefixed with\n  // an underscore, without having to be dropped. The same goes for if the name\n  // is a reserved word.\n  let intermediate = '_'\n\n  // Flag whether the previous character was invalid (and thus dropped).\n  let prevWasInvalid = false\n\n  // Use for/of to iterate over the code points. This way surrogate pairs can\n  // be avoided.\n  for (let char of name) {\n    // Try to uppercase the immediately following (not all characters have an\n    // case equivalent though). Ignore if the dropped character was at the front\n    // of the name.\n    if (prevWasInvalid && intermediate !== '_') {\n      char = char.toUpperCase()\n    }\n\n    // Only include characters if the name remains valid.\n    if (isValidIdentifier(intermediate + char)) {\n      intermediate += char\n      prevWasInvalid = false\n    } else {\n      prevWasInvalid = true\n    }\n  }\n\n  // Return `null` if no characters from the original name survive the process.\n  if (intermediate === '_') return null\n\n  // If the name is valid without the underscore prefix return it as such,\n  // otherwise retain it, unless directed otherwise.\n  const withoutPrefix = intermediate.slice(1)\n  if (isValidIdentifier(withoutPrefix)) {\n    return withoutPrefix\n  } else if (prefixInvalidIdentifiers && prefixReservedWords) {\n    return intermediate\n  } else {\n    const isIdentifierName = keyword.isIdentifierNameES6(withoutPrefix)\n    const isReservedWord = keyword.isReservedWordES6(withoutPrefix, true)\n    if (!isIdentifierName && !prefixInvalidIdentifiers || isReservedWord && !prefixReservedWords) {\n      return withoutPrefix\n    } else {\n      return intermediate\n    }\n  }\n}\n"]}